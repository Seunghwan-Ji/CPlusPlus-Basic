#include <iostream>
#include "Arr.h"
#include <time.h> // 시간 확인과 랜덤 함수 사용 목적

int main()
{
	tArr s1 = {};

	InitArr(&s1);

	// 난수(랜덤)
	// rand();
	// 컴퓨터에서 난수 개념: 무작위로 설정되어 있는 난수 페이지를 참조하는 방식.
	// 실생활에서 예를들면, 종이 한 장에 무작위의 숫자들을 적어서 차례대로 읽는 행위.
	// 결국엔 적혀있는 숫자를 차례대로 읽기 때문에 매번 수행했을 때 패턴이 똑같이 나오는 문제가 있다.

	// srand(); 난수가 작성된 여러 페이지 중, 시드값을 통해 페이지를 선택.
	// 그러나 매번 동일 시드를 주게되면, 똑같은 페이지의 똑같은 패턴의 난수가 나오는 문제가 있다.

	// 시드에 현재까지 흐른 시간값을 넣어 매번 시드값을 다르게 하도록 접근.
	srand(time(nullptr));

	// 0 ~ 100 사이의 난수를 생성하는 법
	// 임의로 나온 난수를 100으로 나눈 나머지 계산.
	// 0 ~ 99까지의 숫자가 나온다.
	// 처음에 101로 나눴으면 0 ~ 100 사이의 난수 생성 가능.

	// 50 ~ 100 사이의 난수를 생성하는 법
	// 일단 두 숫자의 차이는 50이므로, 임의로 나온 난수에 50으로 나눈 나머지를 계산하면 0 ~ 49까지의 숫자가 나오고,
	// 거기에 50을 더하면, 50 ~ 99까지의 숫자가 나온다.
	// 처음에 51로 나눴으면 50 ~ 100 사이의 난수 생성 가능.

	// 1 ~ 100 까지의 임의의 난수 데이터 저장.
	for (int i = 0; i < 10; ++i)
	{
		int iRand = rand() % 100 + 1;
		PushBack(&s1, iRand);
	}

	// 데이터 확인.
	printf("정렬 전\n");
	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}

	// 데이터 정렬 후 재확인.
	printf("\n정렬 후\n");
	Sort(&s1);

	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}

	// 프로그램 종료하기 전, 할당받은 힙 메모리 해제.
	ReleaseArr(&s1);

	return 0;
}

// 개인적으로 버블 정렬 외에 다양한 정렬 방식을 구현해 보자
// - 삽입 정렬
// - 선택 정렬
// - 합병 정렬(merge)
// - 쾌속 정렬(quick)
// - 힙 정렬(완전 이진트리, 배열)