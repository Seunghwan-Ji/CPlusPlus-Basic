#include <stdio.h>

// 메모리 영역
// 1. 스택
// 2. 데이터
// 3. 힙
// 4. ROM(작성 코드)

int main()
{
	// 문자
	// char(1), wchar(2)
	// 문자를 전용으로 나타내기 위한 자료형.
	// 표현 방식은 정수형이지만, 정수를 넣게 되면 정수에 대응하는 문자까지도 보여준다.
	// 1바이트는 0~255까지 수를 나타낼 수 있지만, utf-8 형식은 최상위 비트에 1을 사용하기 때문에 7비트를 사용하여 127가지가 되며,
	// 아스키 코드표에서도 127가지의 문자들이 맵핑된다.

	char c = 'a';
	wchar_t wc = L'a'; // 2바이트 표현으로 문자를 넣어줄 때는 L 을 붙여 명시해준다.(L: 2바이트 크기단위 표현)
	// 'a'는 1바이트로 표현이 가능하지만 wchar_t 는 모든 문자를 통일적으로 2바이트 단위로 쓰기 때문에 L 을 붙인다.
	char szChar[10] = "abcdef";
	wchar_t szWChar[10] = L"abcdef"; // 문자 하나하나가 2바이트인 배열
	// 위 문자 배열들은 끝에 null을 포함하므로 각각 7개의 문자이다.

	// 문자로 배열을 초기화 하는것은 문자열 전용 자료형으로만 초기화가 가능하다.
	// short arrShort[10] = L"abcdef"; short 는 문자 전용 자료형이 아니므로 문자열로 초기화 불가능.
	short arrShort[10] = { 97, 98, 99, 100, 101, 102, 0 }; // 위 문자열 배열의 메모리 공간 상태를 short 로 표현
	// short arrShort[10] = { 97, 98, 99, 100, 101, 102 }; // 배열에 남는 공간은 다 0 이기 때문에 이렇게 표현해도 같다.

	wchar_t szWChaR[10] = { 97, 98, 99, 100, 101, 102 }; // 디버깅 해보면 abcdef 가 같이 표기된다.

	const wchar_t* pChar = L"abcdef"; // 문자열은 주소값을 나타내기 때문에 포인터 변수에 넣을 수 있다.
	// wchar_t 와 L 모두 2바이트 자료형을 나타내기 때문에 포인터 변수와 매칭될 수 있다.


// wchar_t szWChar[10] = L"abcdef"; : "abcdef" 문자 하나하나를 배열에 집어넣어 복사한 개념.
	szWChar[1] = 'z'; // 문자를 복사하여 집어넣은 배열에서 두번째 자리의 문자 'b' 를 'z' 로 변경.

	// const wchar_t* pChar = L"abcdef"; : 포인터로 문자열의 시작 주소를 가리킨다, 복사본이 아닌 원본을 가리키는 상황.
	// L"abcdef" 은 작성자가 작성한 코드 자체이다.
	// 코드는 프로그램이 수행해야 할 명령어이고, 명령어 자체도 메모리상에 존재한다.
	// 이 메모리 영역이 ROM(Read Only Memory)이다.
	// 따라서 포인터 변수는 읽기 전용 메모리 영역의 주소를 가리키고 있는 것이다.

	// pChar[1] = 'z';
	// =
	// *(pChar + 1) = 'z';
	// 시작 주소로 부터 크기단위 만큼 한 칸 뒤에 있는 코드 'b' 를 'z'로 변경하는 행위.
	// 프로그램 실행 도중에 읽기 전용 메모리 영역에 있는 코드를 수정하는 행위가 되므로 잘못된 행위이다.
	// 따라서 값이 변경되지 않아야 하기 때문에, wchar_t* 앞에 const 를 붙여 가리키는 주소의 값을 변경하지 못하도록 상수화 시켜야한다.
	// 또한 문자열 코드의 반환 타입은 const 타입이기 때문에 포인터 변수도 타입을 맞춰 const 를 붙이도록 문법적으로 방어되어 있다.

	wchar_t* pChaR = (wchar_t*)L"abcdef"; // 물론 강제 캐스팅으로 접근할 수는 있다.
	// pChaR[0] = 'z'; // 컴파일러와 링커에서는 오류를 잡지 못하지만, 빌드가 끝나고 프로그램 실행 단계에서 런타임 에러가 발생한다.
					   // 디버깅 시 이 구문에서 예외 발생.(코드 영역을 건드리기 때문)

	return 0;
}