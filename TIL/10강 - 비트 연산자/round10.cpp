// #: 전처리기 구문, 컴파일 과정에서 가장 먼저 수행된다.
#define HUNGRY 1 // 아래 HUNGRY 라는 모든 코드를 1로 치환하는 역할, '매크로'라고 불린다.
// 전처리기 구문의 사용 목적
// 1. 가독성
// 2. 유지보수

int main()
{
	// 자료형 (크기 단위, byte) Data Type
	// 정수형: char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8)

	// 연산자
	// 대입 연산자: =
	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지, 피연산자가 모두 정수)
	// ++, -- (증감 연산자): 한 단계 증가 또는 감소(정수, 실수에서는 +1 증가, -1 감소로 볼 수 있다.)

	// 논리 연산자
	// !(역), &&(and), ||(or)
	// 참(true), 거짓(false)
	// 참  : 0 이 아닌 값, 주로 1
	// 거짓: 0
	// bool 자료형은 참과 거짓만 다루기 때문에 수치로 표현하면 0 과 1 로만 표현된다.

	// 비교 연산자
	// ==, !=, <, <=, >, >=
	// 참, 거짓

	// 구문
	// if, else
	// switch case
	
	// 비트 연산자
	// 쉬프트 <<, >>
	unsigned char byte = 1;

	// byte << 1 모든 비트를 왼쪽으로 한 칸씩 옮긴다. 2^1 = 2배가 커진다.(십진수로 치면 10배가 커지는 개념)
	byte = byte << 1;
	byte <<= 1; // 위와 같은 표현

	byte <<= 3; // 2^3 = 8배가 커진다. 2^n 배수
	byte >>= 3; // 2^n 으로 나눈 몫. 오른쪽으로 이동하면 비트가 잘리기 때문에 1/2배 개념이 아니다. 나머지가 잘림.
	// ex) 이진수 1011(십진수 11) >> 1
	//            0101(십진수 5)
	//            (11 / 2^1 = 5)

	// 비트 곱(&), 합(|), xor(^), 반전(~)
	// 비트 단위로 연산을 진행
	// &: 둘다 1인경우 1
	// ex) 1011 & 0101 = 0001

	// |: 둘중 하나라도 1 이면 1
	// ex) 1011 | 0101 = 1111

	// ^: 둘이 같으면 0, 다르면 1
	// ex) 1011 ^ 0101 = 1110
	
	// ~: 1은 0으로, 0은 1로 반전
	// ex) ~ 1011 = 0100

	int iStatus = HUNGRY; // 위에 전처리기 구문에서 HUNGRY 를 1로 정의했기 때문에 iStatus 변수에 1이 저장된다.

	return 0;

}