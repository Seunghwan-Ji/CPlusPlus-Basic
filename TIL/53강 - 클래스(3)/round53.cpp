#include <iostream>

struct tMy // C++ 구조체 선언 문법
{

};

class CMy
{
	// 접근 제한 지정자: 클래스 내 멤버 변수 및 멤버 함수에 대한 접근 권한을 제어하는 데 사용.
	// private, protected(상속), public

private: // 외부에서 멤버를 볼 수 없다.
	int   m_i;
	float m_f;

public: // 외부에서 멤버를 볼 수 있다.
	int m_j;

public:
	void SetInt(int i)
	{
		m_i = i;
		// 같은 표현
		// this->m_i = i; (이 함수를 호출한 객체의 멤버를 접근하여 수정)
		// C 스타일에서는 객체의 주소를 인자에 포인터 변수로 받았었는데,
		// C++ 에서는 어차피 객체를 통해서 함수가 호출되기에,
		// 기본적으로 객체의 주소를 함수 내부에 숨겨진 this 라는 지역변수에 받아 놓는다.
		// 따라서 그 객체의 주소가 this 이며, 붙이지 않아도 된다.
	}

	// 대입 연산자
	CMy& operator =(const CMy& _Other)
		// operator: 함수명
		// CMy&: 반환 타입
		// const CMy& _Other: 인자로 들어온 다른 객체, 원래 객체 this가 인자로 들어온 객체로 덮어 씌어질 것이기 때문에
		//                    인자로 들어온 객체는 가리키는 주소와 주소로 접근했을 때의 값 모두 보존되어야 하므로,
		//                    const 키워드를 붙인 것이다. 포인터로 치면 가리키는 주소는 레퍼런스 특성상 이미 상수화 상태이고,
		//                    주소로 접근했을 때의 값도 상수화 시킨 것이다.
	{
		// 원래 객체 this 의 멤버의 값을, 인자로 들어온 객체 _Other 의 멤버의 값으로 변경.
		this->m_i = _Other.m_i;
		this->m_f = _Other.m_i;

		return *this; // this 는 주소 타입이므로, 역참조 해서 멤버의 값이 변경된 자신의 객체 반환.
		// 반환 타입은 CMy& 을 사용하여 객체를 참조의 형태로 반환한다.
		// c = c2 = c3; 이 처럼 대입 연산이 연쇄적일 때, 자신의 객체가 다음 대입 연산에서
		// _Other 인자에 들어가고, 인자 타입에도 CMy& 이 들어가기 때문이다.
	}

public:
	// 생성자
	CMy() // 이 클래스의 객체가 생성될 때 호출되는 함수, 컴파일러가 자동으로 호출.
		// 이니셜라이저: 이 클래스의 객체가 만들어지면서 멤버들의 값을 초기화하는 작업.
		: m_i(100)
		, m_f(0.f)
	{

	}

	// 소멸자
	~CMy() // 이 클래스의 객체가 소멸될 때 호출되는 함수, 컴파일러가 자동으로 호출.
	{

	}

};

int main()
{
	// C++ 클래스 특징
	// 생성자, 소멸자
	// 객체 생성, 소멸 시 자동으로 호출.
	// 직접 만들지 않으면, 기본 생성자, 기본 소멸자가 만들어진다.

	// 멤버 함수, ex) SetInt()
	// 해당 클래스가 사용하는 전용 함수.
	// 호출 하려면 해당 클래스의 객체가 필요하다.
	// 멤버 함수를 객체를 통해서 호출하면, 해당 객체의 주소가 this 포인터로 전달된다.
	CMy c;
	c.m_j = 0;
	c.SetInt(10); // 호출 시 객체 c의 주소도 전달됨.

	CMy c2;
	c2.SetInt(100); // 호출 시 객체 c2의 주소도 전달됨.

	CMy c3;
	c3.SetInt(1000); // 호출 시 객체 c3의 주소도 전달됨.

	// 자료형* 변수명: 포인터 변수 선언.
	// *포인터 변수: 역참조하여 포인터 변수에 저장된 주소로 접근.
	// &변수: 선언된 변수의 주소값 반환.
	// 자료형& 변수명: 레퍼런스 변수 선언

	// C++ 에 추가된 기능
	// 포인터와 유사
	// 원본을 참조한다.
	// 참조	변수를 통해서 직접적으로 원본을 수정할 수 있다.

	int a = 10;

	int* const p = &a; // 포인터 변수 자체를 상수화, 가리키는 주소가 고정.
	*p = 100;

	// 같은 표현
	int& iRef = a; // 레퍼런스로 표현
	iRef = 100;

	// 원본을 수정도 못하게 하기
	const int* const p2 = &a; // 가리키는 주소와 주소로 접근했을 때의 값 모두 상수화
	// *p2 = 10; 수정 불가

	// 같은 표현
	const int& iRefConst = a; // 레퍼런스로 표현
	// iRefConst = 10; 수정 불가

	// 대입 연산자
	int i = 0;
	int i2 = 5;
	int i3 = 10;

	i = i2 = i3;
	// i3 의 값 10이 i2 에 전달, i2 의 전달 받은 값 10이 i 에 전달.
	// 최종적으로 i = 10

	c = c2 = c3;
	// 먼저 c2 객체가 대입 연산자 '=' 함수를 호출시키고, 인자(_Other)로 c3 객체가 들어온다.
	// c2 가 c3 의 멤버들의 값으로 덮어씌어 지고, 참조 형태인 c2 가 반환.
	// 이어서 c 가 대입 연산자 함수를 호출 시키고, 참조 형태의 c2 가 인자(_Other)로 들어가고,
	// c 가 c2 의 멤버들의 값으로 덮어씌어 지고, 참조 형태인 c 가 반환.

	return 0;
}