ex) `unsigned int iStatus = 0;`

변수 iStatus 은 32비트 크기의 데이터
비트 한 자리당 한 개의 상태를 추가한다.(예시는 32비트 이므로 32가지의 상태 저장가능.)
상태를 추가할 때 다른 비트 자리의 값은 변하지 않도록 한다.

`0 0 0 ... 0 0 0 0` iStatus

`#define HUNGRY  1` : 십진수 1은 비트로 나타내면 가장 오른쪽 비트만 1이므로, iStatus의 모든 비트에서 첫번째 칸을 배고픔 상태로 추가할 수 있다.
`#define THIRSTY 2` : 십진수 2, 모든 비트에서 두번째 칸을 목마름 상태로 추가할 수 있다.
`#define TIRED   4` : 십진수 4, 모든 비트에서 세번째 칸을 피곤함 상태로 추가할 수 있다.

# 상태 변수에 여러 상태를 추가해보자
ex1)
`iStatus |= HUNGRY;`
상태 변수 iStatus 의 비트와 HUNGRY 의 비트를 합 연산자를 통해 합친다.

`0 0 0 ... 0 0 0 0` iStatus
`|`(둘중 하나라도 1이면 1)
`0 0 0 ... 0 0 0 1` HUNGRY
`=`
`0 0 0 ... 0 0 0 1` 배고픔 상태가 추가된 iStatus 의 비트

ex2)
`iStatus |= THIRSTY`;

`0 0 0 ... 0 0 0 1` iStatus
`|`
`0 0 0 ... 0 0 1 0` THIRSTY
`=`
`0 0 0 ... 0 0 1 1` 배고픔 상태가 유지된 채 목마름 상태가 추가된 iStatus 의 비트

# 상태 체크하기
`if (iStatus & THIRSTY)
 {
 ...(목마름 상태일 때 수행할 문장)
 }`
비트끼리 곱 연산자를 사용해서 상태에 해당하는 비트 자리가 1인지 확인한다.

ex1)
`0 0 0 ... 0 0 1 1` iStatus
`&`(둘다 1인 경우 1)
`0 0 0 ... 0 0 1 0` THIRSTY
`=`
`0 0 0 ... 0 0 1 0` 0이 아닌 수가 나왔으므로 True, 즉, 목마름 상태임이다.

ex2)
`0 0 0 ... 0 0 1 0` iStatus
`&`(둘다 1인 경우 1)
`0 0 0 ... 0 0 0 1` HUNGRY
`=`
`0 0 0 ... 0 0 0 0` 0이 나왔으므로, False, 즉, 배고픔 상태가 아니다.

# 상태 해제하기
예를 들어 피곤함 상태를 해제하려고 한다.
`0 0 0 ... 0 1 1 1` iStatus
`0 0 0 ... 0 1 0 0` TIRED
## xor 연산자 사용해보기
`iStatus ^= TIRED;`

`0 0 0 ... 0 1 1 1` iStatus
`^`(둘이 같으면 0, 다르면 1)
`0 0 0 ... 0 1 0 0` TIRED
`=`
`0 0 0 ... 0 0 1 1` iStatus 변수의 비트에서 피곤함에 해당하는 비트의 자리가 0이 되었다.
### 만약 피곤함 상태가 아니었다면?
`0 0 0 ... 0 0 1 1` iStatus
`^`
`0 0 0 ... 0 1 0 0` TIRED
`=`
`0 0 0 ... 0 1 1 1` 피곤함 상태가 아니었는데, 피곤함 상태가 추가 되버렸다.
따라서 xor 연산자는 이러한 반례가 존재하므로 적합하지 않다.
## 비트를 반전 후 곱 연산자 사용
`iStatus &= ~TIRED;`
iStatus의 비트와 반전된 TIRED의 비트를 곱 연산자를 사용해서 계산한다.
ex1)
`0 0 0 ... 0 1 1 1` iStatus(피곤함 상태)
`&`
`1 1 1 ... 1 0 1 1` 반전된 TIRED
`=`
`0 0 0 ... 0 0 1 1` 피곤한 상태가 해제되었다.

ex2)
`0 0 0 ... 0 0 1 1` iStatus(피곤하지 않은 상태)
`&`
`1 1 1 ... 1 0 1 1` 반전된 TIRED
`=`
`0 0 0 ... 0 0 1 1` 피곤하지 않은 상태가 유지되었다.


이처럼 특정 비트 자리에 상태를 추가하거나 해제하는 과정에서 다른 비트 자리의 값들에 영향을 주지 않는게 포인트다.